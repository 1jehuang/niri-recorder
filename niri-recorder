#!/usr/bin/env python3
"""
niri-recorder - Automated screen recording for Niri compositor

A tool for creating scripted terminal recordings with:
- Kitty remote control for automation
- wf-recorder for capture
- Automatic GIF conversion
"""

import argparse
import subprocess
import time
import os
import sys
import json
import re
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

SOCKET_PATH = "/tmp/niri-recorder-kitty.sock"
NESTED_NIRI_SOCKET = None  # Set dynamically when nested niri starts

@dataclass
class Config:
    output: str = "recording.gif"
    width: str = "80%"
    height: str = "80%"
    fps: int = 12
    scale: int = 800
    workspace: int = 9
    nested: bool = False  # Run inside nested niri

class Recorder:
    def __init__(self, config: Config):
        self.config = config
        self.recorder_proc: Optional[subprocess.Popen] = None
        self.nested_niri_proc: Optional[subprocess.Popen] = None
        self.nested_socket: Optional[str] = None
        self.nested_wayland: Optional[str] = None
        self.nested_window_id: Optional[int] = None
        self.raw_video = "/tmp/niri-recorder-raw.mp4"

    def run_niri(self, *args, nested=False):
        """Run a niri msg action command."""
        cmd = ["niri", "msg", "action"] + list(args)
        env = os.environ.copy()
        if nested and self.nested_socket:
            env["NIRI_SOCKET"] = self.nested_socket
        subprocess.run(cmd, check=True, capture_output=True, env=env)

    def spawn_nested_niri(self):
        """Spawn a nested niri compositor."""
        print("Starting nested niri...")
        self.nested_niri_proc = subprocess.Popen(
            ["niri"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Wait for nested niri to start and find its socket
        for _ in range(50):
            time.sleep(0.1)
            # Find the new wayland socket
            result = subprocess.run(
                ["niri", "msg", "-j", "windows"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                windows = json.loads(result.stdout)
                for w in windows:
                    if w.get("title") == "niri" and w.get("app_id") is None:
                        self.nested_window_id = w["id"]
                        break

            # Find nested wayland display (wayland-2, wayland-3, etc.)
            # Must match exactly "wayland-N" pattern
            for f in os.listdir("/run/user/1000"):
                if re.match(r'^wayland-\d+$', f) and f != "wayland-1":
                    self.nested_wayland = f
                    break

            # Find nested niri socket
            for f in os.listdir("/run/user/1000"):
                if f.startswith("niri.wayland-") and f != "niri.wayland-1.935.sock":
                    sock = f"/run/user/1000/{f}"
                    if sock != os.environ.get("NIRI_SOCKET"):
                        self.nested_socket = sock
                        break

            if self.nested_socket and self.nested_window_id and self.nested_wayland:
                break
        else:
            raise RuntimeError("Failed to start nested niri")

        print(f"Nested niri ready: display={self.nested_wayland}, window={self.nested_window_id}")
        time.sleep(0.3)

    def spawn_terminal(self):
        """Spawn a terminal for recording."""
        env = os.environ.copy()

        if self.config.nested and self.nested_wayland:
            # Use foot in nested mode (kitty has EGL issues in nested niri)
            env["WAYLAND_DISPLAY"] = self.nested_wayland
            print(f"Spawning foot in nested niri ({self.nested_wayland})")

            subprocess.Popen(["foot"], env=env)
            time.sleep(0.5)
        else:
            # Use kitty with remote control in normal mode
            if os.path.exists(SOCKET_PATH):
                os.remove(SOCKET_PATH)

            proc = subprocess.Popen(
                [
                    "kitty",
                    f"--listen-on=unix:{SOCKET_PATH}",
                    "--override", "allow_remote_control=yes"
                ],
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )

            # Wait for socket
            for _ in range(100):
                if os.path.exists(SOCKET_PATH):
                    break
                time.sleep(0.1)

                if proc.poll() is not None:
                    stdout, stderr = proc.communicate()
                    raise RuntimeError(f"Kitty failed to start: {stderr.decode()}")
            else:
                raise RuntimeError("Kitty socket not created (timeout)")

            time.sleep(0.5)

    def setup_window(self):
        """Move terminal to recording workspace and size it."""
        if self.config.nested:
            # Inside nested niri, just size the window
            self.run_niri("set-window-width", self.config.width, nested=True)
            self.run_niri("set-window-height", self.config.height, nested=True)
            self.run_niri("center-column", nested=True)
        else:
            self.run_niri("move-window-to-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("focus-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("set-window-width", self.config.width)
            self.run_niri("set-window-height", self.config.height)
            self.run_niri("center-column")
        time.sleep(0.2)

    def send_text(self, text: str):
        """Send text to the terminal."""
        if self.config.nested:
            # Use wtype for nested mode (foot doesn't have remote control)
            env = os.environ.copy()
            env["WAYLAND_DISPLAY"] = self.nested_wayland
            subprocess.run(["wtype", text], env=env, capture_output=True)
        else:
            # Use kitty remote control
            subprocess.run([
                "kitten", "@", "--to", f"unix:{SOCKET_PATH}",
                "send-text", text
            ], check=True, capture_output=True)

    def send_key(self, key: str):
        """Send a key to the terminal."""
        if self.config.nested:
            # wtype key names
            wtype_keys = {
                "enter": "Return",
                "escape": "Escape",
                "up": "Up",
                "down": "Down",
                "left": "Left",
                "right": "Right",
                "ctrl+u": "-M ctrl u",
                "ctrl+c": "-M ctrl c",
                "ctrl+d": "-M ctrl d",
                "ctrl+w": "-M ctrl w",
                "tab": "Tab",
                "backspace": "BackSpace",
            }

            wtype_key = wtype_keys.get(key.lower(), key)
            env = os.environ.copy()
            env["WAYLAND_DISPLAY"] = self.nested_wayland

            if wtype_key.startswith("-M"):
                # Modifier key combo
                parts = wtype_key.split()
                subprocess.run(["wtype"] + parts, env=env, capture_output=True)
            else:
                subprocess.run(["wtype", "-k", wtype_key], env=env, capture_output=True)
        else:
            # Kitty escape sequences
            key_map = {
                "enter": "\r",
                "escape": "\x1b",
                "up": "\x1b[A",
                "down": "\x1b[B",
                "left": "\x1b[D",
                "right": "\x1b[C",
                "ctrl+u": "\x15",
                "ctrl+c": "\x03",
                "ctrl+d": "\x04",
                "ctrl+w": "\x17",
                "tab": "\t",
                "backspace": "\x7f",
            }

            seq = key_map.get(key.lower(), key)
            self.send_text(seq)

    def start_recording(self):
        """Start wf-recorder."""
        cmd = ["wf-recorder", "-f", self.raw_video, "-y"]
        env = os.environ.copy()

        if self.config.nested and self.nested_wayland:
            # Run wf-recorder inside nested niri to capture full nested display
            env["WAYLAND_DISPLAY"] = self.nested_wayland
        else:
            # Record the full output
            cmd.extend(["-o", "DP-1"])

        self.recorder_proc = subprocess.Popen(
            cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, env=env
        )
        time.sleep(0.5)

    def stop_recording(self):
        """Stop wf-recorder."""
        if self.recorder_proc:
            self.recorder_proc.terminate()
            self.recorder_proc.wait()
            time.sleep(0.3)

    def convert_to_gif(self):
        """Convert raw video to optimized GIF."""
        print(f"Converting to {self.config.output}...")
        subprocess.run([
            "ffmpeg", "-y",
            "-i", self.raw_video,
            "-vf", f"fps={self.config.fps},scale={self.config.scale}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse",
            "-loop", "0",
            self.config.output
        ], check=True, capture_output=True)

        # Cleanup
        os.remove(self.raw_video)

        size = os.path.getsize(self.config.output)
        print(f"Done! {self.config.output} ({size // 1024}KB)")

    def cleanup(self):
        """Close the recording terminal and nested niri."""
        try:
            if self.config.nested:
                self.run_niri("close-window", nested=True)
            else:
                self.run_niri("close-window")
        except:
            pass

        # Kill nested niri
        if self.nested_niri_proc:
            self.nested_niri_proc.terminate()
            try:
                self.nested_niri_proc.wait(timeout=2)
            except:
                self.nested_niri_proc.kill()

        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

def parse_tape(tape_path: str) -> tuple[Config, list[tuple[str, str]]]:
    """Parse a tape file into config and commands."""
    config = Config()
    commands = []

    with open(tape_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if ":" not in line:
                continue

            cmd, _, arg = line.partition(":")
            cmd = cmd.strip().lower()
            arg = arg.strip()

            # Config options
            if cmd == "output":
                config.output = arg
            elif cmd == "width":
                config.width = arg
            elif cmd == "height":
                config.height = arg
            elif cmd == "fps":
                config.fps = int(arg)
            elif cmd == "scale":
                config.scale = int(arg)
            elif cmd == "workspace":
                config.workspace = int(arg)
            elif cmd == "nested":
                config.nested = arg.lower() in ("true", "yes", "1")
            # Commands
            elif cmd in ("type", "sleep", "key", "run"):
                commands.append((cmd, arg))

    return config, commands

def execute_commands(recorder: Recorder, commands: list[tuple[str, str]]):
    """Execute tape commands."""
    for cmd, arg in commands:
        if cmd == "sleep":
            # Parse sleep duration (e.g., "1s", "500ms", "0.5")
            if arg.endswith("ms"):
                duration = float(arg[:-2]) / 1000
            elif arg.endswith("s"):
                duration = float(arg[:-1])
            else:
                duration = float(arg)
            time.sleep(duration)

        elif cmd == "type":
            recorder.send_text(arg)

        elif cmd == "key":
            recorder.send_key(arg)

        elif cmd == "run":
            recorder.send_text(arg + "\r")

def main():
    parser = argparse.ArgumentParser(description="Automated screen recording for Niri")
    parser.add_argument("tape", help="Path to tape file")
    parser.add_argument("-o", "--output", help="Output GIF path (overrides tape)")
    parser.add_argument("--nested", action="store_true", help="Run in nested niri (doesn't take over screen)")
    parser.add_argument("--no-cleanup", action="store_true", help="Don't close terminal after recording")
    args = parser.parse_args()

    # Parse tape
    config, commands = parse_tape(args.tape)
    if args.output:
        config.output = args.output
    if args.nested:
        config.nested = True

    recorder = Recorder(config)

    try:
        if config.nested:
            recorder.spawn_nested_niri()

        print("Spawning terminal...")
        recorder.spawn_terminal()

        print("Setting up window...")
        recorder.setup_window()

        print("Starting recording...")
        recorder.start_recording()

        # Small delay before starting commands
        time.sleep(0.5)

        print("Executing commands...")
        execute_commands(recorder, commands)

        # Small delay after commands
        time.sleep(0.3)

        print("Stopping recording...")
        recorder.stop_recording()

        recorder.convert_to_gif()

    finally:
        if not args.no_cleanup:
            recorder.cleanup()

if __name__ == "__main__":
    main()
