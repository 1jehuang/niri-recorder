#!/usr/bin/env python3
"""
niri-recorder - Automated screen recording for Niri compositor

A tool for creating scripted terminal recordings with:
- Kitty remote control for automation
- wf-recorder for capture
- Automatic GIF conversion
"""

import argparse
import subprocess
import time
import os
import sys
import json
import re
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

SOCKET_PATH = "/tmp/niri-recorder-kitty.sock"
NESTED_NIRI_SOCKET = None  # Set dynamically when nested niri starts

@dataclass
class Config:
    output: str = "recording.gif"
    width: str = "80%"
    height: str = "80%"
    fps: int = 12
    scale: int = 800
    workspace: int = 9
    nested: bool = False  # Run inside nested niri

class Recorder:
    def __init__(self, config: Config):
        self.config = config
        self.recorder_proc: Optional[subprocess.Popen] = None
        self.nested_niri_proc: Optional[subprocess.Popen] = None
        self.nested_socket: Optional[str] = None
        self.nested_wayland: Optional[str] = None
        self.nested_window_id: Optional[int] = None
        self.raw_video = "/tmp/niri-recorder-raw.mp4"
        # Multi-terminal support
        self.terminals: dict[str, int] = {}  # name -> window_id
        self.current_terminal: Optional[str] = None

    def run_niri(self, *args, nested=False):
        """Run a niri msg action command."""
        cmd = ["niri", "msg", "action"] + list(args)
        env = os.environ.copy()
        if nested and self.nested_socket:
            env["NIRI_SOCKET"] = self.nested_socket
        subprocess.run(cmd, check=True, capture_output=True, env=env)

    def spawn_nested_niri(self):
        """Spawn a nested niri compositor."""
        print("Starting nested niri...")
        self.nested_niri_proc = subprocess.Popen(
            ["niri"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Wait for nested niri to start and find its socket
        for _ in range(50):
            time.sleep(0.1)
            # Find the new wayland socket
            result = subprocess.run(
                ["niri", "msg", "-j", "windows"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                windows = json.loads(result.stdout)
                for w in windows:
                    if w.get("title") == "niri" and w.get("app_id") is None:
                        self.nested_window_id = w["id"]
                        break

            # Find nested wayland display (wayland-2, wayland-3, etc.)
            # Must match exactly "wayland-N" pattern
            for f in os.listdir("/run/user/1000"):
                if re.match(r'^wayland-\d+$', f) and f != "wayland-1":
                    self.nested_wayland = f
                    break

            # Find nested niri socket (newer than our start, not the main one)
            main_socket = os.environ.get("NIRI_SOCKET", "")
            for f in os.listdir("/run/user/1000"):
                if f.startswith("niri.wayland-") and f != os.path.basename(main_socket):
                    sock = f"/run/user/1000/{f}"
                    # Check it corresponds to our nested wayland display
                    if self.nested_wayland and f"niri.{self.nested_wayland}" in f:
                        self.nested_socket = sock
                        break

            if self.nested_socket and self.nested_window_id and self.nested_wayland:
                break
        else:
            raise RuntimeError("Failed to start nested niri")

        print(f"Nested niri ready: display={self.nested_wayland}, window={self.nested_window_id}")
        time.sleep(0.3)

    def get_windows(self, nested=False) -> list[dict]:
        """Get list of windows from niri."""
        env = os.environ.copy()
        if nested and self.nested_socket:
            env["NIRI_SOCKET"] = self.nested_socket
        result = subprocess.run(
            ["niri", "msg", "-j", "windows"],
            capture_output=True, text=True, env=env
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
        return []

    def get_newest_foot_window(self, nested=False) -> Optional[int]:
        """Find the most recently created foot window."""
        windows = self.get_windows(nested)
        foot_windows = [w for w in windows if w.get("app_id") == "foot"]
        if foot_windows:
            # Return highest ID (newest)
            return max(w["id"] for w in foot_windows)
        return None

    def spawn_terminal(self, name: str = "default"):
        """Spawn a named terminal for recording."""
        env = os.environ.copy()

        if self.config.nested and self.nested_wayland:
            # Use foot in nested mode (kitty has EGL issues in nested niri)
            env["WAYLAND_DISPLAY"] = self.nested_wayland
            print(f"Spawning terminal '{name}' in nested niri")

            # Get existing window IDs before spawning
            existing_ids = {w["id"] for w in self.get_windows(nested=True) if w.get("app_id") == "foot"}

            subprocess.Popen(["foot"], env=env)
            time.sleep(0.5)

            # Find the new window ID (one that didn't exist before)
            for _ in range(10):
                windows = self.get_windows(nested=True)
                for w in windows:
                    if w.get("app_id") == "foot" and w["id"] not in existing_ids:
                        self.terminals[name] = w["id"]
                        self.current_terminal = name
                        print(f"  -> window id {w['id']}")
                        break
                if name in self.terminals:
                    break
                time.sleep(0.1)
        else:
            # Use kitty with remote control in normal mode
            if os.path.exists(SOCKET_PATH):
                os.remove(SOCKET_PATH)

            proc = subprocess.Popen(
                [
                    "kitty",
                    f"--listen-on=unix:{SOCKET_PATH}",
                    "--override", "allow_remote_control=yes"
                ],
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )

            # Wait for socket
            for _ in range(100):
                if os.path.exists(SOCKET_PATH):
                    break
                time.sleep(0.1)

                if proc.poll() is not None:
                    stdout, stderr = proc.communicate()
                    raise RuntimeError(f"Kitty failed to start: {stderr.decode()}")
            else:
                raise RuntimeError("Kitty socket not created (timeout)")

            time.sleep(0.5)
            self.terminals[name] = 0  # Kitty mode doesn't track window IDs
            self.current_terminal = name

    def focus_terminal(self, name: str):
        """Focus a terminal by name, spawning if needed."""
        if name not in self.terminals:
            print(f"Creating new terminal '{name}'")
            self.spawn_terminal(name)
            self.setup_window()
            return

        if self.config.nested and name != self.current_terminal:
            window_id = self.terminals[name]
            print(f"Focusing terminal '{name}' (window {window_id})")
            self.run_niri("focus-window", "--id", str(window_id), nested=True)
            time.sleep(0.2)

        self.current_terminal = name

    def setup_window(self):
        """Move terminal to recording workspace and size it."""
        if self.config.nested:
            # Inside nested niri, just size the window
            self.run_niri("set-window-width", self.config.width, nested=True)
            self.run_niri("set-window-height", self.config.height, nested=True)
            self.run_niri("center-column", nested=True)
        else:
            self.run_niri("move-window-to-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("focus-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("set-window-width", self.config.width)
            self.run_niri("set-window-height", self.config.height)
            self.run_niri("center-column")
        time.sleep(0.2)

    def send_text(self, text: str):
        """Send text to the terminal."""
        if self.config.nested:
            # Use wtype for nested mode (foot doesn't have remote control)
            env = os.environ.copy()
            env["WAYLAND_DISPLAY"] = self.nested_wayland
            subprocess.run(["wtype", text], env=env, capture_output=True)
        else:
            # Use kitty remote control
            subprocess.run([
                "kitten", "@", "--to", f"unix:{SOCKET_PATH}",
                "send-text", text
            ], check=True, capture_output=True)

    def send_key(self, key: str):
        """Send a key to the terminal."""
        if self.config.nested:
            # wtype key names
            wtype_keys = {
                "enter": "Return",
                "escape": "Escape",
                "up": "Up",
                "down": "Down",
                "left": "Left",
                "right": "Right",
                "ctrl+u": "-M ctrl u",
                "ctrl+c": "-M ctrl c",
                "ctrl+d": "-M ctrl d",
                "ctrl+w": "-M ctrl w",
                "tab": "Tab",
                "backspace": "BackSpace",
            }

            wtype_key = wtype_keys.get(key.lower(), key)
            env = os.environ.copy()
            env["WAYLAND_DISPLAY"] = self.nested_wayland

            if wtype_key.startswith("-M"):
                # Modifier key combo
                parts = wtype_key.split()
                subprocess.run(["wtype"] + parts, env=env, capture_output=True)
            else:
                subprocess.run(["wtype", "-k", wtype_key], env=env, capture_output=True)
        else:
            # Kitty escape sequences
            key_map = {
                "enter": "\r",
                "escape": "\x1b",
                "up": "\x1b[A",
                "down": "\x1b[B",
                "left": "\x1b[D",
                "right": "\x1b[C",
                "ctrl+u": "\x15",
                "ctrl+c": "\x03",
                "ctrl+d": "\x04",
                "ctrl+w": "\x17",
                "tab": "\t",
                "backspace": "\x7f",
            }

            seq = key_map.get(key.lower(), key)
            self.send_text(seq)

    def start_recording(self):
        """Start wf-recorder."""
        cmd = ["wf-recorder", "-f", self.raw_video, "-y"]
        env = os.environ.copy()

        if self.config.nested and self.nested_wayland:
            # Run wf-recorder inside nested niri to capture full nested display
            env["WAYLAND_DISPLAY"] = self.nested_wayland
        else:
            # Record the full output
            cmd.extend(["-o", "DP-1"])

        self.recorder_proc = subprocess.Popen(
            cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, env=env
        )
        time.sleep(0.5)

    def stop_recording(self):
        """Stop wf-recorder."""
        if self.recorder_proc:
            self.recorder_proc.terminate()
            self.recorder_proc.wait()
            time.sleep(0.3)

    def convert_to_gif(self):
        """Convert raw video to optimized GIF."""
        print(f"Converting to {self.config.output}...")
        subprocess.run([
            "ffmpeg", "-y",
            "-i", self.raw_video,
            "-vf", f"fps={self.config.fps},scale={self.config.scale}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse",
            "-loop", "0",
            self.config.output
        ], check=True, capture_output=True)

        # Cleanup
        os.remove(self.raw_video)

        size = os.path.getsize(self.config.output)
        print(f"Done! {self.config.output} ({size // 1024}KB)")

    def cleanup(self):
        """Close the recording terminal and nested niri."""
        try:
            if self.config.nested:
                self.run_niri("close-window", nested=True)
            else:
                self.run_niri("close-window")
        except:
            pass

        # Kill nested niri
        if self.nested_niri_proc:
            self.nested_niri_proc.terminate()
            try:
                self.nested_niri_proc.wait(timeout=2)
            except:
                self.nested_niri_proc.kill()

        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

def parse_tape(tape_path: str) -> tuple[Config, list[tuple[str, str]]]:
    """Parse a tape file into config and commands."""
    config = Config()
    commands = []

    with open(tape_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if ":" not in line:
                continue

            cmd, _, arg = line.partition(":")
            cmd = cmd.strip().lower()
            arg = arg.strip()

            # Config options
            if cmd == "output":
                config.output = arg
            elif cmd == "width":
                config.width = arg
            elif cmd == "height":
                config.height = arg
            elif cmd == "fps":
                config.fps = int(arg)
            elif cmd == "scale":
                config.scale = int(arg)
            elif cmd == "workspace":
                config.workspace = int(arg)
            elif cmd == "nested":
                config.nested = arg.lower() in ("true", "yes", "1")
            # Commands
            elif cmd in ("type", "sleep", "key", "run", "terminal", "focus"):
                commands.append((cmd, arg))

    return config, commands

def execute_commands(recorder: Recorder, commands: list[tuple[str, str]]):
    """Execute tape commands."""
    for cmd, arg in commands:
        if cmd == "sleep":
            # Parse sleep duration (e.g., "1s", "500ms", "0.5")
            if arg.endswith("ms"):
                duration = float(arg[:-2]) / 1000
            elif arg.endswith("s"):
                duration = float(arg[:-1])
            else:
                duration = float(arg)
            time.sleep(duration)

        elif cmd == "type":
            recorder.send_text(arg)

        elif cmd == "key":
            recorder.send_key(arg)

        elif cmd == "run":
            recorder.send_text(arg + "\r")

        elif cmd == "terminal" or cmd == "focus":
            # Switch to (or create) a named terminal
            recorder.focus_terminal(arg)

def main():
    parser = argparse.ArgumentParser(description="Automated screen recording for Niri")
    parser.add_argument("tape", help="Path to tape file")
    parser.add_argument("-o", "--output", help="Output GIF path (overrides tape)")
    parser.add_argument("--nested", action="store_true", help="Run in nested niri (doesn't take over screen)")
    parser.add_argument("--no-cleanup", action="store_true", help="Don't close terminal after recording")
    args = parser.parse_args()

    # Parse tape
    config, commands = parse_tape(args.tape)
    if args.output:
        config.output = args.output
    if args.nested:
        config.nested = True

    recorder = Recorder(config)

    try:
        if config.nested:
            recorder.spawn_nested_niri()

        print("Spawning terminal...")
        recorder.spawn_terminal("main")

        print("Setting up window...")
        recorder.setup_window()

        print("Starting recording...")
        recorder.start_recording()

        # Small delay before starting commands
        time.sleep(0.5)

        print("Executing commands...")
        execute_commands(recorder, commands)

        # Small delay after commands
        time.sleep(0.3)

        print("Stopping recording...")
        recorder.stop_recording()

        recorder.convert_to_gif()

    finally:
        if not args.no_cleanup:
            recorder.cleanup()

if __name__ == "__main__":
    main()
