#!/usr/bin/env python3
"""
niri-recorder - Automated screen recording for Niri compositor

A tool for creating scripted terminal recordings with:
- Kitty remote control for automation
- wf-recorder for capture
- Automatic GIF conversion
"""

import argparse
import subprocess
import time
import os
import sys
import json
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

SOCKET_PATH = "/tmp/niri-recorder-kitty.sock"

@dataclass
class Config:
    output: str = "recording.gif"
    width: str = "80%"
    height: str = "80%"
    fps: int = 12
    scale: int = 800
    workspace: int = 9

class Recorder:
    def __init__(self, config: Config):
        self.config = config
        self.recorder_proc: Optional[subprocess.Popen] = None
        self.raw_video = "/tmp/niri-recorder-raw.mp4"

    def run_niri(self, *args):
        """Run a niri msg action command."""
        cmd = ["niri", "msg", "action"] + list(args)
        subprocess.run(cmd, check=True, capture_output=True)

    def spawn_terminal(self):
        """Spawn a kitty terminal with remote control socket."""
        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

        subprocess.Popen([
            "kitty",
            f"--listen-on=unix:{SOCKET_PATH}",
            "--override", "allow_remote_control=yes"
        ])

        # Wait for socket
        for _ in range(50):
            if os.path.exists(SOCKET_PATH):
                break
            time.sleep(0.1)
        else:
            raise RuntimeError("Kitty socket not created")

        time.sleep(0.3)

    def setup_window(self):
        """Move terminal to recording workspace and size it."""
        self.run_niri("move-window-to-workspace", str(self.config.workspace))
        time.sleep(0.2)
        self.run_niri("focus-workspace", str(self.config.workspace))
        time.sleep(0.2)
        self.run_niri("set-window-width", self.config.width)
        self.run_niri("set-window-height", self.config.height)
        self.run_niri("center-column")
        time.sleep(0.2)

    def send_text(self, text: str):
        """Send text to the kitty terminal."""
        subprocess.run([
            "kitten", "@", "--to", f"unix:{SOCKET_PATH}",
            "send-text", text
        ], check=True, capture_output=True)

    def send_key(self, key: str):
        """Send a key to the terminal."""
        key_map = {
            "enter": "\r",
            "escape": "\x1b",
            "up": "\x1b[A",
            "down": "\x1b[B",
            "left": "\x1b[D",
            "right": "\x1b[C",
            "ctrl+u": "\x15",
            "ctrl+c": "\x03",
            "ctrl+d": "\x04",
            "ctrl+w": "\x17",
            "tab": "\t",
            "backspace": "\x7f",
        }

        seq = key_map.get(key.lower(), key)
        self.send_text(seq)

    def start_recording(self):
        """Start wf-recorder."""
        self.recorder_proc = subprocess.Popen([
            "wf-recorder",
            "-o", "DP-1",
            "-f", self.raw_video,
            "-y"  # overwrite
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        time.sleep(0.5)

    def stop_recording(self):
        """Stop wf-recorder."""
        if self.recorder_proc:
            self.recorder_proc.terminate()
            self.recorder_proc.wait()
            time.sleep(0.3)

    def convert_to_gif(self):
        """Convert raw video to optimized GIF."""
        print(f"Converting to {self.config.output}...")
        subprocess.run([
            "ffmpeg", "-y",
            "-i", self.raw_video,
            "-vf", f"fps={self.config.fps},scale={self.config.scale}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse",
            "-loop", "0",
            self.config.output
        ], check=True, capture_output=True)

        # Cleanup
        os.remove(self.raw_video)

        size = os.path.getsize(self.config.output)
        print(f"Done! {self.config.output} ({size // 1024}KB)")

    def cleanup(self):
        """Close the recording terminal."""
        try:
            self.run_niri("close-window")
        except:
            pass
        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

def parse_tape(tape_path: str) -> tuple[Config, list[tuple[str, str]]]:
    """Parse a tape file into config and commands."""
    config = Config()
    commands = []

    with open(tape_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if ":" not in line:
                continue

            cmd, _, arg = line.partition(":")
            cmd = cmd.strip().lower()
            arg = arg.strip()

            # Config options
            if cmd == "output":
                config.output = arg
            elif cmd == "width":
                config.width = arg
            elif cmd == "height":
                config.height = arg
            elif cmd == "fps":
                config.fps = int(arg)
            elif cmd == "scale":
                config.scale = int(arg)
            elif cmd == "workspace":
                config.workspace = int(arg)
            # Commands
            elif cmd in ("type", "sleep", "key", "run"):
                commands.append((cmd, arg))

    return config, commands

def execute_commands(recorder: Recorder, commands: list[tuple[str, str]]):
    """Execute tape commands."""
    for cmd, arg in commands:
        if cmd == "sleep":
            # Parse sleep duration (e.g., "1s", "500ms", "0.5")
            if arg.endswith("ms"):
                duration = float(arg[:-2]) / 1000
            elif arg.endswith("s"):
                duration = float(arg[:-1])
            else:
                duration = float(arg)
            time.sleep(duration)

        elif cmd == "type":
            recorder.send_text(arg)

        elif cmd == "key":
            recorder.send_key(arg)

        elif cmd == "run":
            recorder.send_text(arg + "\r")

def main():
    parser = argparse.ArgumentParser(description="Automated screen recording for Niri")
    parser.add_argument("tape", help="Path to tape file")
    parser.add_argument("-o", "--output", help="Output GIF path (overrides tape)")
    parser.add_argument("--no-cleanup", action="store_true", help="Don't close terminal after recording")
    args = parser.parse_args()

    # Parse tape
    config, commands = parse_tape(args.tape)
    if args.output:
        config.output = args.output

    recorder = Recorder(config)

    try:
        print("Spawning terminal...")
        recorder.spawn_terminal()

        print("Setting up window...")
        recorder.setup_window()

        print("Starting recording...")
        recorder.start_recording()

        # Small delay before starting commands
        time.sleep(0.5)

        print("Executing commands...")
        execute_commands(recorder, commands)

        # Small delay after commands
        time.sleep(0.3)

        print("Stopping recording...")
        recorder.stop_recording()

        recorder.convert_to_gif()

    finally:
        if not args.no_cleanup:
            recorder.cleanup()

if __name__ == "__main__":
    main()
