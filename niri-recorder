#!/usr/bin/env python3
"""
niri-recorder - Automated screen recording for Niri compositor

A tool for creating scripted terminal recordings with:
- Kitty remote control for automation
- wf-recorder for capture
- Automatic GIF conversion
"""

import argparse
import subprocess
import time
import os
import sys
import json
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

SOCKET_PATH = "/tmp/niri-recorder-kitty.sock"
NESTED_NIRI_SOCKET = None  # Set dynamically when nested niri starts

@dataclass
class Config:
    output: str = "recording.gif"
    width: str = "80%"
    height: str = "80%"
    fps: int = 12
    scale: int = 800
    workspace: int = 9
    nested: bool = False  # Run inside nested niri

class Recorder:
    def __init__(self, config: Config):
        self.config = config
        self.recorder_proc: Optional[subprocess.Popen] = None
        self.nested_niri_proc: Optional[subprocess.Popen] = None
        self.nested_socket: Optional[str] = None
        self.nested_wayland: Optional[str] = None
        self.nested_window_id: Optional[int] = None
        self.raw_video = "/tmp/niri-recorder-raw.mp4"

    def run_niri(self, *args, nested=False):
        """Run a niri msg action command."""
        cmd = ["niri", "msg", "action"] + list(args)
        env = os.environ.copy()
        if nested and self.nested_socket:
            env["NIRI_SOCKET"] = self.nested_socket
        subprocess.run(cmd, check=True, capture_output=True, env=env)

    def spawn_nested_niri(self):
        """Spawn a nested niri compositor."""
        print("Starting nested niri...")
        self.nested_niri_proc = subprocess.Popen(
            ["niri"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        # Wait for nested niri to start and find its socket
        for _ in range(50):
            time.sleep(0.1)
            # Find the new wayland socket
            result = subprocess.run(
                ["niri", "msg", "-j", "windows"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                windows = json.loads(result.stdout)
                for w in windows:
                    if w.get("title") == "niri" and w.get("app_id") is None:
                        self.nested_window_id = w["id"]
                        break

            # Find nested socket
            for f in os.listdir("/run/user/1000"):
                if f.startswith("niri.wayland-") and f != "niri.wayland-1.935.sock":
                    sock = f"/run/user/1000/{f}"
                    if sock != os.environ.get("NIRI_SOCKET"):
                        self.nested_socket = sock
                        # Extract wayland display name
                        parts = f.split(".")
                        if len(parts) >= 2:
                            self.nested_wayland = parts[1]  # e.g., "wayland-2"
                        break

            if self.nested_socket and self.nested_window_id:
                break
        else:
            raise RuntimeError("Failed to start nested niri")

        print(f"Nested niri ready: socket={self.nested_socket}, window={self.nested_window_id}")
        time.sleep(0.3)

    def get_nested_geometry(self) -> str:
        """Get the geometry string for the nested niri window."""
        result = subprocess.run(
            ["niri", "msg", "-j", "windows"],
            capture_output=True, text=True, check=True
        )
        windows = json.loads(result.stdout)

        for w in windows:
            if w["id"] == self.nested_window_id:
                # Get window size
                width = int(w["layout"]["window_size"][0])
                height = int(w["layout"]["window_size"][1])

                # For position, we need to focus and use slurp, or estimate
                # For now, use slurp to select the window
                print("Click on the nested niri window to select it for recording...")
                result = subprocess.run(["slurp"], capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip()

                # Fallback: assume it's visible and use its size
                return f"0,0 {width}x{height}"

        raise RuntimeError("Nested niri window not found")

    def spawn_terminal(self):
        """Spawn a kitty terminal with remote control socket."""
        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

        env = os.environ.copy()
        if self.config.nested and self.nested_wayland:
            env["WAYLAND_DISPLAY"] = self.nested_wayland

        subprocess.Popen([
            "kitty",
            f"--listen-on=unix:{SOCKET_PATH}",
            "--override", "allow_remote_control=yes"
        ], env=env)

        # Wait for socket
        for _ in range(50):
            if os.path.exists(SOCKET_PATH):
                break
            time.sleep(0.1)
        else:
            raise RuntimeError("Kitty socket not created")

        time.sleep(0.3)

    def setup_window(self):
        """Move terminal to recording workspace and size it."""
        if self.config.nested:
            # Inside nested niri, just size the window
            self.run_niri("set-window-width", self.config.width, nested=True)
            self.run_niri("set-window-height", self.config.height, nested=True)
            self.run_niri("center-column", nested=True)
        else:
            self.run_niri("move-window-to-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("focus-workspace", str(self.config.workspace))
            time.sleep(0.2)
            self.run_niri("set-window-width", self.config.width)
            self.run_niri("set-window-height", self.config.height)
            self.run_niri("center-column")
        time.sleep(0.2)

    def send_text(self, text: str):
        """Send text to the kitty terminal."""
        subprocess.run([
            "kitten", "@", "--to", f"unix:{SOCKET_PATH}",
            "send-text", text
        ], check=True, capture_output=True)

    def send_key(self, key: str):
        """Send a key to the terminal."""
        key_map = {
            "enter": "\r",
            "escape": "\x1b",
            "up": "\x1b[A",
            "down": "\x1b[B",
            "left": "\x1b[D",
            "right": "\x1b[C",
            "ctrl+u": "\x15",
            "ctrl+c": "\x03",
            "ctrl+d": "\x04",
            "ctrl+w": "\x17",
            "tab": "\t",
            "backspace": "\x7f",
        }

        seq = key_map.get(key.lower(), key)
        self.send_text(seq)

    def start_recording(self):
        """Start wf-recorder."""
        cmd = ["wf-recorder", "-f", self.raw_video, "-y"]

        if self.config.nested and self.nested_window_id:
            # Record just the nested niri window
            geometry = self.get_nested_geometry()
            cmd.extend(["-g", geometry])
        else:
            # Record the full output
            cmd.extend(["-o", "DP-1"])

        self.recorder_proc = subprocess.Popen(
            cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        time.sleep(0.5)

    def stop_recording(self):
        """Stop wf-recorder."""
        if self.recorder_proc:
            self.recorder_proc.terminate()
            self.recorder_proc.wait()
            time.sleep(0.3)

    def convert_to_gif(self):
        """Convert raw video to optimized GIF."""
        print(f"Converting to {self.config.output}...")
        subprocess.run([
            "ffmpeg", "-y",
            "-i", self.raw_video,
            "-vf", f"fps={self.config.fps},scale={self.config.scale}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse",
            "-loop", "0",
            self.config.output
        ], check=True, capture_output=True)

        # Cleanup
        os.remove(self.raw_video)

        size = os.path.getsize(self.config.output)
        print(f"Done! {self.config.output} ({size // 1024}KB)")

    def cleanup(self):
        """Close the recording terminal and nested niri."""
        try:
            if self.config.nested:
                self.run_niri("close-window", nested=True)
            else:
                self.run_niri("close-window")
        except:
            pass

        # Kill nested niri
        if self.nested_niri_proc:
            self.nested_niri_proc.terminate()
            try:
                self.nested_niri_proc.wait(timeout=2)
            except:
                self.nested_niri_proc.kill()

        if os.path.exists(SOCKET_PATH):
            os.remove(SOCKET_PATH)

def parse_tape(tape_path: str) -> tuple[Config, list[tuple[str, str]]]:
    """Parse a tape file into config and commands."""
    config = Config()
    commands = []

    with open(tape_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if ":" not in line:
                continue

            cmd, _, arg = line.partition(":")
            cmd = cmd.strip().lower()
            arg = arg.strip()

            # Config options
            if cmd == "output":
                config.output = arg
            elif cmd == "width":
                config.width = arg
            elif cmd == "height":
                config.height = arg
            elif cmd == "fps":
                config.fps = int(arg)
            elif cmd == "scale":
                config.scale = int(arg)
            elif cmd == "workspace":
                config.workspace = int(arg)
            elif cmd == "nested":
                config.nested = arg.lower() in ("true", "yes", "1")
            # Commands
            elif cmd in ("type", "sleep", "key", "run"):
                commands.append((cmd, arg))

    return config, commands

def execute_commands(recorder: Recorder, commands: list[tuple[str, str]]):
    """Execute tape commands."""
    for cmd, arg in commands:
        if cmd == "sleep":
            # Parse sleep duration (e.g., "1s", "500ms", "0.5")
            if arg.endswith("ms"):
                duration = float(arg[:-2]) / 1000
            elif arg.endswith("s"):
                duration = float(arg[:-1])
            else:
                duration = float(arg)
            time.sleep(duration)

        elif cmd == "type":
            recorder.send_text(arg)

        elif cmd == "key":
            recorder.send_key(arg)

        elif cmd == "run":
            recorder.send_text(arg + "\r")

def main():
    parser = argparse.ArgumentParser(description="Automated screen recording for Niri")
    parser.add_argument("tape", help="Path to tape file")
    parser.add_argument("-o", "--output", help="Output GIF path (overrides tape)")
    parser.add_argument("--nested", action="store_true", help="Run in nested niri (doesn't take over screen)")
    parser.add_argument("--no-cleanup", action="store_true", help="Don't close terminal after recording")
    args = parser.parse_args()

    # Parse tape
    config, commands = parse_tape(args.tape)
    if args.output:
        config.output = args.output
    if args.nested:
        config.nested = True

    recorder = Recorder(config)

    try:
        if config.nested:
            recorder.spawn_nested_niri()

        print("Spawning terminal...")
        recorder.spawn_terminal()

        print("Setting up window...")
        recorder.setup_window()

        print("Starting recording...")
        recorder.start_recording()

        # Small delay before starting commands
        time.sleep(0.5)

        print("Executing commands...")
        execute_commands(recorder, commands)

        # Small delay after commands
        time.sleep(0.3)

        print("Stopping recording...")
        recorder.stop_recording()

        recorder.convert_to_gif()

    finally:
        if not args.no_cleanup:
            recorder.cleanup()

if __name__ == "__main__":
    main()
